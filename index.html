<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Educator + 3CS Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; margin: 0; }
        .chat-bubble { animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .typing-indicator { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }

        /* Single column app layout */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 800px;
            margin: 0 auto;
        }

        /* Tab header */
        .tab-header {
            display: flex;
            border-bottom: 1px solid #334155;
            background: #1e293b;
        }
        .tab-btn {
            padding: 0.75rem 1.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: #94a3b8;
            border: none;
            background: transparent;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tab-btn:hover { color: #e2e8f0; }
        .tab-btn.active {
            color: #10b981;
            border-bottom-color: #10b981;
        }
        .tab-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Content area */
        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        /* Fixed input bar at bottom */
        .input-bar {
            padding: 0.75rem 1rem;
            border-top: 1px solid #334155;
            background: #1e293b;
        }

        /* Voice signal display */
        .voice-signal {
            position: fixed;
            top: 80px;
            right: 20px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 12px 16px;
            z-index: 100;
            min-width: 180px;
        }
        .voice-emoji { font-size: 1.5rem; text-align: center; margin-bottom: 6px; }
        .voice-metrics { font-size: 0.65rem; color: #94a3b8; }
        .voice-interpretation { font-size: 0.7rem; color: #cbd5e1; margin-top: 6px; font-style: italic; }

        /* Recording indicator */
        .recording-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: #ef4444;
            border-radius: 50%;
            animation: pulse-recording 1s infinite;
        }
        @keyframes pulse-recording {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-50">
    <div class="app-container">
        <!-- Tab Header -->
        <div class="tab-header">
            <button onclick="showTab('chat')" id="tab-chat" class="tab-btn active">Chat</button>
            <button onclick="showTab('projects')" id="tab-projects" class="tab-btn" disabled>Projects</button>
            <div class="flex-1"></div>
            <span class="text-xs text-slate-500 self-center pr-4" id="exchange-count">0 exchanges</span>
        </div>

        <!-- Content Area - Chat -->
        <div id="content-chat" class="content-area">
            <div id="chat-messages" role="log" aria-live="polite">
                <div class="chat-bubble flex gap-3 mb-4">
                    <div class="w-8 h-8 rounded-full bg-blue-500 flex-shrink-0 flex items-center justify-center text-xs font-semibold">AI</div>
                    <div class="bg-slate-700 rounded-lg p-3 max-w-[85%]">
                        <p class="text-sm">Hey! I'm here to help you figure out if this is a fit.</p>
                        <p class="text-sm mt-2">This is a live-in builder role in West Michigan. You'd work 10-60 hrs/month on real projects‚ÄîAI tools, coordination software, food systems.</p>
                        <p class="text-sm mt-2 text-slate-400">What are you curious about?</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Content Area - Projects (hidden until unlocked) -->
        <div id="content-projects" class="content-area hidden">
            <div id="projects-list"></div>
        </div>

        <!-- Fixed Input Bar -->
        <div class="input-bar">
            <!-- Mode toggles + recording status -->
            <div class="flex justify-between items-center mb-2">
                <div class="flex gap-2">
                    <button onclick="toggleInputMode()" id="input-mode-btn"
                        class="px-3 py-1 rounded text-xs font-mono bg-slate-700 hover:bg-slate-600 flex items-center gap-1">
                        <span id="input-mode-icon">‚å®Ô∏è</span>
                        <span id="input-mode-text">Type</span>
                    </button>
                    <button onclick="toggleOutputMode()" id="output-mode-btn"
                        class="px-3 py-1 rounded text-xs font-mono bg-slate-700 hover:bg-slate-600 flex items-center gap-1">
                        <span id="output-mode-icon">üìù</span>
                        <span id="output-mode-text">Read</span>
                    </button>
                </div>
                <div id="recording-status" class="hidden flex items-center gap-2 text-red-400 text-xs">
                    <span class="recording-indicator"></span>
                    <span id="recording-time">0:00</span>
                </div>
            </div>

            <!-- Input controls -->
            <div class="flex gap-2">
                <div id="text-input-container" class="flex-1 flex gap-2">
                    <input type="text" id="chat-input" placeholder="Ask anything..."
                        class="flex-1 bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-blue-500"
                        onkeypress="if(event.key==='Enter')sendMessage()">
                    <button onclick="sendMessage()" id="send-btn" class="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded-lg text-sm font-semibold">Send</button>
                </div>
                <div id="voice-input-container" class="hidden flex-1">
                    <button onclick="toggleRecording()" id="record-btn"
                        class="w-full bg-red-500 hover:bg-red-600 px-4 py-2 rounded-lg text-sm font-semibold flex items-center justify-center gap-2">
                        <span id="record-icon">üé§</span>
                        <span id="record-text">Click to record</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Voice Signal Display (floating) -->
    <div id="voice-signal-display" class="voice-signal hidden">
        <div class="voice-emoji" id="signal-emoji">üòê</div>
        <div class="voice-metrics">
            <div><span class="text-slate-400">Pace:</span> <span id="signal-wpm">--</span> WPM</div>
            <div><span class="text-slate-400">Pauses:</span> <span id="signal-pauses">--</span></div>
            <div><span class="text-slate-400">Confidence:</span> <span id="signal-confidence">--</span></div>
        </div>
        <div class="voice-interpretation" id="signal-interpretation">Listening...</div>
    </div>

        <!-- Invite Modal -->
        <div id="invite-modal" class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50">
            <div class="bg-slate-900 border border-slate-700 rounded-lg p-6 max-w-md mx-4">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold">Invite a Friend</h3>
                    <button onclick="closeInviteModal()" class="text-slate-400 hover:text-white text-xl">&times;</button>
                </div>

                <!-- Step 1: Enter friend's info -->
                <div id="invite-step-1">
                    <p class="text-sm text-slate-400 mb-4">Send a personal invite to someone you think would thrive here.</p>

                    <label class="text-xs text-slate-500 block mb-1">Their name (optional)</label>
                    <input type="text" id="invitee-name" placeholder="Friend's name"
                        class="w-full bg-slate-800 border border-slate-700 rounded-lg px-4 py-2 text-sm mb-3 focus:outline-none focus:border-purple-500">

                    <label class="text-xs text-slate-500 block mb-1">Their email (optional)</label>
                    <input type="email" id="invitee-email" placeholder="friend@email.com"
                        class="w-full bg-slate-800 border border-slate-700 rounded-lg px-4 py-2 text-sm mb-4 focus:outline-none focus:border-purple-500">

                    <p class="text-xs text-slate-500 mb-4">Leave email blank to create an open invite link you can share yourself.</p>

                    <button onclick="generateInvite()" id="generate-invite-btn" class="w-full bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded-lg text-sm font-semibold">
                        Create Invite
                    </button>
                </div>

                <!-- Step 2: Show invite link -->
                <div id="invite-step-2" class="hidden">
                    <div class="bg-slate-800 border border-purple-500/30 rounded-lg p-4 mb-4">
                        <p class="text-xs text-slate-500 mb-2">Share this link:</p>
                        <div class="flex gap-2">
                            <input type="text" id="invite-url" readonly
                                class="flex-1 bg-slate-900 border border-slate-700 rounded px-3 py-2 text-sm text-purple-300 font-mono">
                            <button onclick="copyInviteUrl()" class="bg-purple-500 hover:bg-purple-600 px-3 py-2 rounded text-sm">
                                Copy
                            </button>
                        </div>
                    </div>

                    <p class="text-xs text-slate-400 mb-4" id="invite-expires">Expires in 7 days</p>

                    <div class="flex gap-2">
                        <button onclick="createAnotherInvite()" class="flex-1 bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded-lg text-sm">
                            Create another
                        </button>
                        <button onclick="closeInviteModal()" class="flex-1 bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded-lg text-sm font-semibold">
                            Done
                        </button>
                    </div>
                </div>

                <!-- Your invite stats -->
                <div class="mt-6 pt-4 border-t border-slate-700">
                    <p class="text-xs text-slate-500 mb-2">Your referrals</p>
                    <div class="flex justify-between text-sm">
                        <span class="text-slate-400">Invites sent</span>
                        <span id="invite-count" class="text-purple-300">0</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span class="text-slate-400">Conversions</span>
                        <span id="conversion-count" class="text-emerald-300">0</span>
                    </div>
                </div>
            </div>
        </div>



    <script>
        // State
        let exchanges = 0;
        let selectedProjects = [];
        let chatHistory = [];
        let userEmail = '';
        let sessionId = '';
        let projects = [];
        let isStreaming = false;
        let fitScore = 0;
        let canUnlockEmail = false;
        let lastMetadata = null;
        let projectsUnlocked = false;

        // Modality state
        let inputModality = 'text';  // 'text' or 'voice'
        let outputModality = 'text'; // 'text' or 'voice'

        // Voice recording state
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimer = null;

        // Invite state
        let inviteCode = null;

        // Tab navigation
        function showTab(tab) {
            document.getElementById('tab-chat').classList.toggle('active', tab === 'chat');
            document.getElementById('tab-projects').classList.toggle('active', tab === 'projects');
            document.getElementById('content-chat').classList.toggle('hidden', tab !== 'chat');
            document.getElementById('content-projects').classList.toggle('hidden', tab !== 'projects');
        }

        function unlockProjects() {
            if (projectsUnlocked) return;
            projectsUnlocked = true;
            document.getElementById('tab-projects').disabled = false;
            loadProjects();
        }

        // Generate or retrieve sessionId from localStorage
        function getOrCreateSessionId() {
            let id = localStorage.getItem('sessionId');
            if (!id) {
                id = 'session_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                localStorage.setItem('sessionId', id);
            }
            return id;
        }

        // Initialize
        async function init() {
            sessionId = getOrCreateSessionId();
            console.log('Session ID:', sessionId);

            // Load projects
            try {
                const response = await fetch('/data/projects.json');
                projects = await response.json();
            } catch (e) {
                console.error('Failed to load projects:', e);
                projects = [];
            }

            // Try to recover existing session from KV
            await recoverSession();

            document.getElementById('chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !isStreaming) sendMessage();
            });

            // Check for invite code in URL
            checkForInviteCode();
        }

        // Resume session by email (cross-device)
        async function resumeByEmail(email) {
            try {
                const response = await fetch(`/api/resume?email=${encodeURIComponent(email)}`);
                if (!response.ok) return false;

                const data = await response.json();
                if (!data.found || !data.hasConversation) {
                    return false;
                }

                // Set session ID and persist to localStorage
                sessionId = data.sessionId;
                localStorage.setItem('sessionId', sessionId);
                userEmail = data.email;

                // Restore state
                chatHistory = data.chatHistory;
                exchanges = data.exchanges;

                if (data.lastMetadata) {
                    fitScore = data.lastMetadata.fitScore || 0;
                    canUnlockEmail = data.lastMetadata.canUnlockEmail || false;
                }

                // Render messages
                const container = document.getElementById('chat-messages');
                container.innerHTML = '';
                for (const msg of chatHistory) {
                    addChatMessage(msg.content, msg.role);
                }

                // Update UI
                updateExchangeCount();
                if (fitScore > 0) updateFitDisplay();
                if (canUnlockEmail) showEmailGate();
                if (exchanges >= 15) unlockProjects();

                console.log(`Resumed session for ${email}: ${exchanges} exchanges`);
                return true;
            } catch (e) {
                console.error('Resume by email failed:', e.message);
                return false;
            }
        }

        // Session recovery - restores chat from KV if session exists
        async function recoverSession() {
            try {
                const response = await fetch(`/api/session?sessionId=${encodeURIComponent(sessionId)}`);
                if (!response.ok) return;

                const data = await response.json();
                if (!data.found || !data.chatHistory || data.chatHistory.length === 0) {
                    console.log('No existing session to recover');
                    return;
                }

                console.log(`Recovering session: ${data.exchanges} exchanges`);

                // Restore chat history
                chatHistory = data.chatHistory;
                exchanges = data.exchanges;

                // Restore UI state
                if (data.lastMetadata) {
                    fitScore = data.lastMetadata.fitScore || 0;
                    canUnlockEmail = data.lastMetadata.canUnlockEmail || false;
                }

                // Render recovered messages (skip the initial AI greeting which is already in HTML)
                const container = document.getElementById('chat-messages');
                // Clear the default greeting
                container.innerHTML = '';

                for (const msg of chatHistory) {
                    addChatMessage(msg.content, msg.role);
                }

                // Update UI
                updateExchangeCount();
                if (fitScore > 0) updateFitDisplay();
                if (canUnlockEmail) showEmailGate();
                if (exchanges >= 15) unlockProjects();

                console.log('Session recovered successfully');
            } catch (e) {
                console.log('Session recovery skipped:', e.message);
            }
        }

        // Chat
        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            if (!message || isStreaming) return;

            // Add user message
            addChatMessage(message, 'user');
            chatHistory.push({ role: 'user', content: message });
            input.value = '';
            exchanges++;
            updateExchangeCount();

            // Log message
            logMessage(message, 'user');

            // Show typing indicator
            const typingDiv = showTyping();
            isStreaming = true;
            input.disabled = true;
            document.getElementById('send-btn').disabled = true;

            try {
                const response = await fetch(`/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: chatHistory,
                        sessionId: sessionId,
                        email: userEmail || null
                    })
                });

                if (!response.ok) throw new Error('API error');

                typingDiv.remove();

                // Stream response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let aiMessage = '';
                let messageDiv = null;
                let streamComplete = false;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done || streamComplete) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                streamComplete = true;
                                break;
                            }

                            try {
                                const parsed = JSON.parse(data);
                                if (parsed.text) {
                                    aiMessage += parsed.text;
                                    if (!messageDiv) {
                                        messageDiv = addChatMessage(aiMessage, 'assistant');
                                    } else {
                                        messageDiv.querySelector('p').textContent = aiMessage;
                                    }
                                }
                                if (parsed.type === 'metadata') {
                                    // Store full metadata for Playwright access
                                    lastMetadata = {
                                        speechAct: parsed.speechAct,
                                        dialogueAct: parsed.dialogueAct,
                                        criteria: parsed.criteria,
                                        rubricScores: parsed.rubricScores,
                                        fitScore: parsed.fitScore,
                                        allFloorsPass: parsed.allFloorsPass,
                                        rationale: parsed.rationale,
                                        canUnlockEmail: parsed.canUnlockEmail
                                    };

                                    // Expose metadata in message element for Playwright
                                    if (messageDiv) {
                                        messageDiv.setAttribute('data-metadata', JSON.stringify(lastMetadata));
                                        messageDiv.setAttribute('data-role', 'assistant');
                                    }

                                    fitScore = parsed.fitScore;
                                    canUnlockEmail = parsed.canUnlockEmail;
                                    updateFitDisplay();
                                    if (canUnlockEmail) {
                                        showEmailGate();
                                    }
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }

                chatHistory.push({ role: 'assistant', content: aiMessage });
                logMessage(aiMessage, 'assistant');

                // Auto-unlock projects at 15 exchanges
                if (exchanges >= 15) {
                    unlockProjects();
                }

                // If output modality is voice, speak the response with word-by-word reveal
                if (outputModality === 'voice' && aiMessage && messageDiv) {
                    speakResponse(aiMessage, messageDiv);
                }

            } catch (error) {
                console.error('API error:', error);
                typingDiv.remove();
                addChatMessage('Sorry, something went wrong. Please try again.', 'assistant');
            }

            isStreaming = false;
            input.disabled = false;
            document.getElementById('send-btn').disabled = false;
            input.focus();
        }

        function addChatMessage(text, role) {
            const container = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = 'chat-bubble flex gap-3' + (role === 'user' ? ' flex-row-reverse' : '');

            // Build DOM safely to prevent XSS
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'w-8 h-8 rounded-full flex-shrink-0 flex items-center justify-center text-xs' +
                (role === 'user' ? ' bg-emerald-500' : ' bg-blue-500 font-semibold');
            avatarDiv.textContent = role === 'user' ? 'You' : 'AI';

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = (role === 'user' ? 'bg-emerald-500/20' : 'bg-slate-700') + ' rounded-lg p-3 max-w-[75%]';

            const textP = document.createElement('p');
            textP.className = 'text-sm';
            textP.textContent = text; // Safe: uses textContent, not innerHTML
            bubbleDiv.appendChild(textP);

            div.appendChild(avatarDiv);
            div.appendChild(bubbleDiv);
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
            return div;
        }

        function showTyping() {
            const container = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = 'chat-bubble flex gap-3';
            div.innerHTML = `
                <div class="w-8 h-8 rounded-full bg-blue-500 flex-shrink-0 flex items-center justify-center text-xs font-semibold">AI</div>
                <div class="bg-slate-700 rounded-lg p-3">
                    <div class="flex gap-1">
                        <span class="typing-indicator">‚óè</span>
                        <span class="typing-indicator" style="animation-delay: 0.2s;">‚óè</span>
                        <span class="typing-indicator" style="animation-delay: 0.4s;">‚óè</span>
                    </div>
                </div>
            `;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
            return div;
        }

        function updateExchangeCount() {
            document.getElementById('exchange-count').textContent = `${exchanges} exchanges`;
        }

        function logMessage(content, role) {
            fetch(`/api/log-message`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    email: userEmail,
                    message: content,
                    role,
                    timestamp: new Date().toISOString(),
                    stage: getCurrentStage(),
                    projectsInterested: selectedProjects.map(p => p.id)
                })
            }).catch(e => console.error('Log error:', e));
        }

        function getCurrentStage() {
            // Check which tab is active
            const projectsTab = document.getElementById('tab-projects');
            if (projectsTab && projectsTab.classList.contains('active')) return 'projects';
            return 'chat';
        }

        function focusChat() {
            document.getElementById('chat-input').focus();
        }

        // Simple modality toggles - work anytime
        function toggleInputMode() {
            if (inputModality === 'text') {
                inputModality = 'voice';
                document.getElementById('input-mode-icon').textContent = 'üé§';
                document.getElementById('input-mode-text').textContent = 'Speak';
                document.getElementById('input-mode-btn').classList.add('bg-red-600');
                document.getElementById('input-mode-btn').classList.remove('bg-slate-700');
                document.getElementById('text-input-container').classList.add('hidden');
                document.getElementById('voice-input-container').classList.remove('hidden');
                initVoiceRecording();
            } else {
                inputModality = 'text';
                document.getElementById('input-mode-icon').textContent = '‚å®Ô∏è';
                document.getElementById('input-mode-text').textContent = 'Type';
                document.getElementById('input-mode-btn').classList.remove('bg-red-600');
                document.getElementById('input-mode-btn').classList.add('bg-slate-700');
                document.getElementById('text-input-container').classList.remove('hidden');
                document.getElementById('voice-input-container').classList.add('hidden');
                document.getElementById('chat-input').focus();
            }
        }

        function toggleOutputMode() {
            if (outputModality === 'text') {
                outputModality = 'voice';
                document.getElementById('output-mode-icon').textContent = 'üîä';
                document.getElementById('output-mode-text').textContent = 'Listen';
                document.getElementById('output-mode-btn').classList.add('bg-blue-600');
                document.getElementById('output-mode-btn').classList.remove('bg-slate-700');
            } else {
                outputModality = 'text';
                document.getElementById('output-mode-icon').textContent = 'üìù';
                document.getElementById('output-mode-text').textContent = 'Read';
                document.getElementById('output-mode-btn').classList.remove('bg-blue-600');
                document.getElementById('output-mode-btn').classList.add('bg-slate-700');
                // Stop any ongoing speech
                stopSpeaking();
            }
        }

        // Legacy functions for initial screen (if still used)
        function selectInputModality(modality) {
            if (modality === 'voice' && inputModality === 'text') toggleInputMode();
            else if (modality === 'text' && inputModality === 'voice') toggleInputMode();
        }

        function selectOutputModality(modality) {
            if (modality === 'voice' && outputModality === 'text') toggleOutputMode();
            else if (modality === 'text' && outputModality === 'voice') toggleOutputMode();
        }

        function updateModalitySummary() {
            const inputText = inputModality === 'text' ? 'type' : 'speak';
            const outputText = outputModality === 'text' ? 'text' : 'voice';
            const summary = document.getElementById('modality-summary');
            if (summary) {
                summary.textContent = `You'll ${inputText}, AI will respond with ${outputText}`;
            }
        }

        // Voice recording
        async function initVoiceRecording() {
            document.getElementById('record-text').textContent = 'Requesting mic...';

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // Check for supported mime type
                let mimeType = 'audio/webm';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/mp4';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = ''; // Let browser choose
                    }
                }

                mediaRecorder = mimeType
                    ? new MediaRecorder(stream, { mimeType })
                    : new MediaRecorder(stream);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
                    audioChunks = [];
                    await processVoiceInput(audioBlob);
                };

                document.getElementById('record-text').textContent = 'Click to record';
                document.getElementById('record-btn').classList.remove('opacity-50');
                console.log('Voice recording initialized with', mediaRecorder.mimeType);
            } catch (error) {
                console.error('Failed to initialize voice recording:', error);
                document.getElementById('record-text').textContent = 'Mic unavailable';
                document.getElementById('record-btn').classList.add('opacity-50');
                alert('Could not access microphone: ' + error.message + '\n\nPlease check browser permissions and try again.');
            }
        }

        function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            if (!mediaRecorder) {
                alert('Microphone not ready. Please allow microphone access and refresh the page.');
                return;
            }
            if (isStreaming) {
                console.log('Cannot record while AI is responding');
                return;
            }

            audioChunks = [];
            mediaRecorder.start();
            isRecording = true;
            recordingStartTime = Date.now();

            // Update UI
            document.getElementById('record-btn').classList.add('bg-red-600', 'animate-pulse');
            document.getElementById('record-text').textContent = 'Recording...';
            document.getElementById('recording-status').classList.remove('hidden');
            document.getElementById('voice-signal-display').classList.remove('hidden');

            // Start recording timer
            recordingTimer = setInterval(updateRecordingTime, 100);
        }

        function stopRecording() {
            if (!mediaRecorder || !isRecording) return;

            mediaRecorder.stop();
            isRecording = false;

            // Update UI
            document.getElementById('record-btn').classList.remove('bg-red-600', 'animate-pulse');
            document.getElementById('record-text').textContent = 'Processing...';
            document.getElementById('recording-status').classList.add('hidden');

            // Stop timer
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
        }

        function updateRecordingTime() {
            if (!recordingStartTime) return;
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            document.getElementById('recording-time').textContent =
                `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        async function processVoiceInput(audioBlob) {
            try {
                // Convert to base64 (chunked to avoid stack overflow)
                const arrayBuffer = await audioBlob.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                let binary = '';
                const chunkSize = 8192;
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    const chunk = bytes.subarray(i, i + chunkSize);
                    binary += String.fromCharCode.apply(null, chunk);
                }
                const base64 = btoa(binary);

                // Get the actual mimeType from the blob
                const format = audioBlob.type || 'audio/webm';

                // Send to voice analysis API
                const response = await fetch('/api/voice-analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        audio: base64,
                        format: format,
                        sessionId: sessionId
                    })
                });

                if (!response.ok) throw new Error('Voice analysis failed');

                const result = await response.json();

                // Update voice signal display
                updateVoiceSignalDisplay(result);

                // If we got a transcript, send it as a message
                if (result.transcript && result.transcript.trim()) {
                    // Add user message from transcript
                    addChatMessage(result.transcript, 'user');
                    chatHistory.push({ role: 'user', content: result.transcript });
                    exchanges++;
                    updateExchangeCount();

                    // Get AI response
                    await getAIResponse();
                } else {
                    document.getElementById('record-text').textContent = 'No speech detected. Try again.';
                    setTimeout(() => {
                        document.getElementById('record-text').textContent = 'Click to record';
                    }, 2000);
                }

            } catch (error) {
                console.error('Voice processing error:', error);
                document.getElementById('record-text').textContent = 'Error. Try again.';
                setTimeout(() => {
                    document.getElementById('record-text').textContent = 'Click to record';
                }, 2000);
            }
        }

        function updateVoiceSignalDisplay(result) {
            const display = document.getElementById('voice-signal-display');
            display.classList.remove('hidden');

            // Update emoji
            document.getElementById('signal-emoji').textContent = result.emoji || 'üòê';

            // Update metrics
            document.getElementById('signal-wpm').textContent = result.signals?.wpm || '--';
            document.getElementById('signal-pauses').textContent =
                result.signals?.pauses?.count || 0;
            document.getElementById('signal-confidence').textContent =
                result.signals?.confidence || '--';

            // Update interpretation
            document.getElementById('signal-interpretation').textContent =
                result.interpretation || 'Analyzing...';

            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (!isRecording) {
                    display.classList.add('hidden');
                }
            }, 10000);
        }

        async function getAIResponse() {
            const typingDiv = showTyping();
            isStreaming = true;

            try {
                const response = await fetch(`/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: chatHistory,
                        sessionId: sessionId,
                        email: userEmail || null
                    })
                });

                if (!response.ok) throw new Error('API error');

                typingDiv.remove();

                // Stream response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let aiMessage = '';
                let messageDiv = null;
                let streamComplete = false;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done || streamComplete) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                streamComplete = true;
                                break;
                            }

                            try {
                                const parsed = JSON.parse(data);
                                if (parsed.text) {
                                    aiMessage += parsed.text;
                                    if (!messageDiv) {
                                        messageDiv = addChatMessage(aiMessage, 'assistant');
                                    } else {
                                        messageDiv.querySelector('p').textContent = aiMessage;
                                    }
                                }
                                if (parsed.type === 'metadata') {
                                    lastMetadata = {
                                        speechAct: parsed.speechAct,
                                        dialogueAct: parsed.dialogueAct,
                                        criteria: parsed.criteria,
                                        rubricScores: parsed.rubricScores,
                                        fitScore: parsed.fitScore,
                                        allFloorsPass: parsed.allFloorsPass,
                                        rationale: parsed.rationale,
                                        canUnlockEmail: parsed.canUnlockEmail
                                    };

                                    if (messageDiv) {
                                        messageDiv.setAttribute('data-metadata', JSON.stringify(lastMetadata));
                                        messageDiv.setAttribute('data-role', 'assistant');
                                    }

                                    fitScore = parsed.fitScore;
                                    canUnlockEmail = parsed.canUnlockEmail;
                                    updateFitDisplay();
                                    if (canUnlockEmail) {
                                        showEmailGate();
                                    }
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }

                chatHistory.push({ role: 'assistant', content: aiMessage });
                logMessage(aiMessage, 'assistant');

                // If output modality is voice, speak the response with word-by-word reveal
                if (outputModality === 'voice' && aiMessage && messageDiv) {
                    speakResponse(aiMessage, messageDiv);
                }

                // Auto-unlock projects at 15 exchanges
                if (exchanges >= 15) {
                    unlockProjects();
                }

            } catch (error) {
                console.error('API error:', error);
                typingDiv.remove();
                addChatMessage('Sorry, something went wrong. Please try again.', 'assistant');
            }

            isStreaming = false;
            document.getElementById('record-text').textContent = 'Click to record';
        }

        // Text-to-speech using OpenAI TTS API with word-by-word reveal
        let currentAudio = null;
        let currentRevealElement = null;

        async function speakResponse(text, messageElement) {
            // Stop any currently playing audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            const words = text.split(/(\s+)/); // Keep whitespace for proper display
            const textElement = messageElement?.querySelector('p');

            // Start with empty text if we have an element to reveal into
            if (textElement) {
                textElement.textContent = '';
                textElement.dataset.fullText = text; // Store for stopSpeaking
                currentRevealElement = textElement;
            }

            try {
                console.log('TTS: Requesting audio for', text.length, 'chars');

                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        voice: 'nova'  // Options: alloy, echo, fable, onyx, nova, shimmer
                    })
                });

                if (!response.ok) {
                    throw new Error(`TTS API error: ${response.status}`);
                }

                // Get audio as blob and play it
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);

                currentAudio = new Audio(audioUrl);

                // Word-by-word reveal synced to audio playback
                let lastWordIndex = 0;
                currentAudio.ontimeupdate = () => {
                    if (!textElement || !currentAudio.duration) return;

                    const progress = currentAudio.currentTime / currentAudio.duration;
                    const targetWordIndex = Math.floor(words.length * progress);

                    if (targetWordIndex > lastWordIndex) {
                        // Reveal words up to current position
                        const visibleText = words.slice(0, targetWordIndex + 1).join('');
                        textElement.textContent = visibleText;
                        lastWordIndex = targetWordIndex;
                    }
                };

                currentAudio.onplay = () => console.log('TTS: Playing');

                currentAudio.onended = () => {
                    console.log('TTS: Finished');
                    // Show full text when done
                    if (textElement) {
                        textElement.textContent = text;
                    }
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                    currentRevealElement = null;
                };

                currentAudio.onerror = (e) => {
                    console.error('TTS: Playback error', e);
                    // Show full text on error
                    if (textElement) {
                        textElement.textContent = text;
                    }
                    URL.revokeObjectURL(audioUrl);
                };

                await currentAudio.play();

            } catch (error) {
                console.error('TTS error:', error);
                // Show full text on error
                if (textElement) {
                    textElement.textContent = text;
                }
                // Fallback to browser TTS if OpenAI fails
                if ('speechSynthesis' in window) {
                    console.log('TTS: Falling back to browser speech');
                    speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 0.95;
                    speechSynthesis.speak(utterance);
                }
            }
        }

        // Stop TTS when switching to Read mode
        function stopSpeaking() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            // Show full text if we were mid-reveal
            if (currentRevealElement && currentRevealElement.dataset.fullText) {
                currentRevealElement.textContent = currentRevealElement.dataset.fullText;
            }
            currentRevealElement = null;
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
        }

        // Invite system
        function showInviteModal() {
            document.getElementById('invite-modal').classList.remove('hidden');
            document.getElementById('invite-step-1').classList.remove('hidden');
            document.getElementById('invite-step-2').classList.add('hidden');
            loadInviteStats();
        }

        function closeInviteModal() {
            document.getElementById('invite-modal').classList.add('hidden');
        }

        async function generateInvite() {
            const inviteeName = document.getElementById('invitee-name').value.trim();
            const inviteeEmail = document.getElementById('invitee-email').value.trim();

            if (!userEmail) {
                alert('Please submit your application first to invite friends.');
                return;
            }

            document.getElementById('generate-invite-btn').textContent = 'Creating...';
            document.getElementById('generate-invite-btn').disabled = true;

            try {
                const response = await fetch('/api/invite?action=generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        inviterEmail: userEmail,
                        inviteeEmail: inviteeEmail || null,
                        inviteeName: inviteeName || null
                    })
                });

                if (!response.ok) throw new Error('Failed to create invite');

                const result = await response.json();
                inviteCode = result.code;

                // Show step 2 with the invite URL
                document.getElementById('invite-url').value = result.inviteUrl;
                document.getElementById('invite-expires').textContent =
                    `Expires: ${new Date(result.expiresAt).toLocaleDateString()}`;

                document.getElementById('invite-step-1').classList.add('hidden');
                document.getElementById('invite-step-2').classList.remove('hidden');

                // Refresh stats
                loadInviteStats();

            } catch (error) {
                console.error('Invite creation error:', error);
                alert('Failed to create invite. Please try again.');
            }

            document.getElementById('generate-invite-btn').textContent = 'Create Invite';
            document.getElementById('generate-invite-btn').disabled = false;
        }

        function copyInviteUrl() {
            const urlInput = document.getElementById('invite-url');
            urlInput.select();
            document.execCommand('copy');

            // Visual feedback
            const copyBtn = event.target;
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            setTimeout(() => {
                copyBtn.textContent = originalText;
            }, 2000);
        }

        function createAnotherInvite() {
            document.getElementById('invitee-name').value = '';
            document.getElementById('invitee-email').value = '';
            document.getElementById('invite-step-1').classList.remove('hidden');
            document.getElementById('invite-step-2').classList.add('hidden');
        }

        async function loadInviteStats() {
            if (!userEmail) return;

            try {
                const response = await fetch(`/api/invite?action=list&email=${encodeURIComponent(userEmail)}`);
                if (!response.ok) return;

                const data = await response.json();
                document.getElementById('invite-count').textContent = data.invites?.length || 0;
                document.getElementById('conversion-count').textContent = data.conversions || 0;
            } catch (error) {
                console.log('Could not load invite stats:', error.message);
            }
        }

        // Check for invite code in URL on page load
        function checkForInviteCode() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('invite');

            if (code) {
                validateInviteCode(code);
            }
        }

        async function validateInviteCode(code) {
            try {
                const response = await fetch(`/api/invite?action=validate&code=${code}`);
                const result = await response.json();

                if (result.valid) {
                    // Store the invite code for later conversion
                    localStorage.setItem('pendingInviteCode', code);

                    // Show welcome message
                    const welcomeMsg = result.inviteeName
                        ? `Welcome, ${result.inviteeName}! You were invited by ${result.invitedBy}.`
                        : `Welcome! You were invited by ${result.invitedBy}.`;

                    // Add a welcome banner
                    const banner = document.createElement('div');
                    banner.className = 'fixed top-0 left-0 right-0 bg-purple-500 text-white text-center py-2 text-sm z-50';
                    banner.textContent = welcomeMsg;
                    document.body.prepend(banner);

                    // Remove from URL without reload
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            } catch (error) {
                console.log('Invalid invite code:', error.message);
            }
        }

        // Convert invite when user submits email
        async function convertInvite() {
            const pendingCode = localStorage.getItem('pendingInviteCode');
            if (!pendingCode || !userEmail) return;

            try {
                await fetch('/api/invite?action=convert', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        code: pendingCode,
                        email: userEmail
                    })
                });
                localStorage.removeItem('pendingInviteCode');
            } catch (error) {
                console.log('Invite conversion failed:', error.message);
            }
        }

        // Projects - color map for Tailwind JIT compatibility
        const projectColorMap = {
            emerald: { border: 'hover:border-emerald-500/50', text: 'text-emerald-300', bg: 'bg-emerald-500/20' },
            blue: { border: 'hover:border-blue-500/50', text: 'text-blue-300', bg: 'bg-blue-500/20' },
            purple: { border: 'hover:border-purple-500/50', text: 'text-purple-300', bg: 'bg-purple-500/20' },
            amber: { border: 'hover:border-amber-500/50', text: 'text-amber-300', bg: 'bg-amber-500/20' },
            rose: { border: 'hover:border-rose-500/50', text: 'text-rose-300', bg: 'bg-rose-500/20' },
            cyan: { border: 'hover:border-cyan-500/50', text: 'text-cyan-300', bg: 'bg-cyan-500/20' },
        };
        const defaultColor = { border: 'hover:border-slate-500/50', text: 'text-slate-300', bg: 'bg-slate-500/20' };

        function getProjectColor(colorName) {
            return projectColorMap[colorName] || defaultColor;
        }

        function loadProjects() {
            const container = document.getElementById('projects-list');
            if (!container || !projects.length) return;

            container.innerHTML = `
                <h2 class="text-lg font-semibold mb-4">What interests you?</h2>
                <div class="grid gap-4">
                    ${projects.map(p => {
                        const colors = getProjectColor(p.color);
                        const isSelected = selectedProjects.some(sp => sp.id === p.id);
                        return `
                            <div class="bg-slate-900 border ${isSelected ? 'border-emerald-500' : 'border-slate-700'} rounded-lg p-4 cursor-pointer ${colors.border} transition" onclick="toggleProject('${p.id}')">
                                <div class="flex justify-between items-start">
                                    <p class="${colors.text} text-sm font-medium">${p.name}</p>
                                    <span id="project-${p.id}-status" class="text-xs ${isSelected ? 'text-emerald-400' : 'text-slate-500'}">${isSelected ? '‚úì Selected' : ''}</span>
                                </div>
                                <p class="text-xs text-slate-400 mt-1">${p.description}</p>
                            </div>
                        `;
                    }).join('')}
                </div>
                ${selectedProjects.length > 0 ? `
                    <div class="mt-6 p-4 bg-slate-800 rounded-lg">
                        <p class="text-sm text-slate-400 mb-2">Selected: ${selectedProjects.map(p => p.name).join(', ')}</p>
                        <button onclick="showInviteModal()" class="w-full bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded-lg text-sm font-semibold">
                            Invite a Friend
                        </button>
                    </div>
                ` : ''}
            `;
        }

        function toggleProject(projectId) {
            const project = projects.find(p => p.id === projectId);
            const idx = selectedProjects.findIndex(p => p.id === projectId);

            if (idx >= 0) {
                selectedProjects.splice(idx, 1);
            } else if (project) {
                selectedProjects.push(project);
            }

            // Re-render projects to update selection state
            loadProjects();
        }


        // Fit score display
        function updateFitDisplay() {
            let display = document.getElementById('fit-score-display');
            if (!display) {
                display = document.createElement('div');
                display.id = 'fit-score-display';
                display.className = 'bg-slate-900 border border-slate-700 rounded-lg p-4 mb-4 text-center';
                const messagesContainer = document.getElementById('chat-messages');
                messagesContainer.parentElement.insertBefore(display, messagesContainer);
            }
            display.innerHTML = `
                <p class="text-sm text-slate-500 mb-2">Fit Score</p>
                <p class="text-2xl font-bold text-emerald-400">${fitScore}/100</p>
                ${canUnlockEmail ? '<p class="text-xs text-emerald-400 mt-2">‚úì Ready to continue</p>' : ''}
            `;
        }

        // Email gate
        function showEmailGate() {
            let gate = document.getElementById('email-gate-container');
            if (!gate) {
                gate = document.createElement('div');
                gate.id = 'email-gate-container';
                const messagesContainer = document.getElementById('chat-messages');
                messagesContainer.parentElement.insertBefore(gate, messagesContainer);
            }
            gate.className = 'bg-slate-900 border border-blue-500/30 rounded-lg p-4 mb-4';
            gate.innerHTML = `
                <p class="text-sm text-blue-300 font-semibold mb-3">Ready to move forward?</p>
                <input type="email" id="gate-email" placeholder="your@email.com"
                    class="w-full bg-slate-800 border border-slate-700 rounded-lg px-4 py-2 text-sm mb-3 focus:outline-none focus:border-blue-500">
                <button onclick="submitEmail()" class="w-full bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded-lg text-sm font-semibold">
                    Continue
                </button>
            `;
        }

        async function submitEmail() {
            const email = document.getElementById('gate-email').value.trim();
            if (!email) {
                alert('Please enter your email');
                return;
            }
            userEmail = email;

            // Link email to session for cross-device resume
            try {
                await fetch(`/api/magic-link`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, sessionId, name: '' })
                });
            } catch (error) {
                console.error('Failed to link email to session:', error);
            }

            // Convert any pending invite
            await convertInvite();

            document.getElementById('email-gate-container').remove();
            unlockProjects();
            showTab('projects');
        }

        init();
    </script>
</body>
</html>
